# API Documentation

## Общая информация

Эта документация описывает API для системы чатов между покупателями и продавцами. API предоставляет доступ к функциям обмена сообщениями, получения списка чатов и управления статусами пользователей.

Базовый URL: `http://<host>:<port>/`

## WebSocket соединение

### Установка соединения

```
GET /ws/{userId}
```

**Параметры пути:**
- `userId` (int, обязательный) - ID пользователя, от имени которого устанавливается соединение

**Описание:**
Устанавливает WebSocket соединение для указанного пользователя. После установки соединения пользователь может обмениваться сообщениями в реальном времени.

**Пример:**
```
ws://localhost:8080/ws/123
```

### Формат сообщений WebSocket

#### Отправка сообщения

```json
{
  "type": "message",
  "fromId": 123,
  "toId": 456,
  "productId": 789,
  "content": "Текст сообщения"
}
```

#### Уведомление о статусе

```json
{
  "type": "status",
  "userId": 123,
  "status": "online",
  "isActive": true
}
```

## HTTP API эндпоинты

### Получение списка чатов

```
GET /api/chats
```

**Параметры запроса:**
- `userId` или `user_id` (int, обязательный) - ID пользователя, для которого нужно получить список чатов

**Ответ:**
```json
{
  "chats": [
    {
      "id": 1,
      "buyerId": 123,
      "sellerId": 456,
      "productId": 789,
      "lastMessage": "Текст последнего сообщения",
      "lastMessageTime": "13:45",
      "unreadCount": 2,
      "createdAt": "2023-04-10T15:04:05Z"
    },
    ...
  ]
}
```

**Коды ответов:**
- `200 OK` - Успешное выполнение запроса
- `400 Bad Request` - Отсутствуют обязательные параметры
- `500 Internal Server Error` - Ошибка сервера при выполнении запроса

### Получение истории сообщений

```
GET /api/messages
```

**Параметры запроса:**
- `userId` или `u_id` (int, обязательный) - ID пользователя, запрашивающего историю
- `chatWith` или `chat_with` (int, обязательный) - ID собеседника

**Ответ:**
```json
{
  "messages": [
    {
      "id": 1,
      "fromId": 123,
      "toId": 456,
      "productId": 789,
      "content": "Текст сообщения",
      "timestamp": "13:45",
      "createdAt": "2023-04-10T15:04:05Z"
    },
    ...
  ]
}
```

**Коды ответов:**
- `200 OK` - Успешное выполнение запроса
- `400 Bad Request` - Отсутствуют обязательные параметры
- `500 Internal Server Error` - Ошибка сервера при выполнении запроса

### Обновление статуса пользователя

```
POST /api/status
```

**Тело запроса:**
```json
{
  "userId": 123,
  "status": "online",
  "isActive": true
}
```

**Параметры:**
- `userId` (int, обязательный) - ID пользователя
- `status` (string, обязательный) - Статус пользователя ("online", "offline", "away")
- `isActive` (boolean, опциональный) - Флаг активности пользователя

**Ответ:**
```json
{
  "success": true,
  "message": "Статус пользователя обновлен"
}
```

**Коды ответов:**
- `200 OK` - Успешное выполнение запроса
- `400 Bad Request` - Неверный формат запроса или отсутствуют обязательные параметры
- `500 Internal Server Error` - Ошибка сервера при выполнении запроса

## Форматы данных

### Чат (Chat)

| Поле             | Тип     | Описание                                    |
|------------------|---------|---------------------------------------------|
| id               | int     | Уникальный идентификатор чата              |
| buyerId          | int     | ID покупателя                              |
| sellerId         | int     | ID продавца                                |
| productId        | int     | ID товара, о котором ведется обсуждение    |
| lastMessage      | string  | Текст последнего сообщения в чате          |
| lastMessageTime  | string  | Время последнего сообщения (форматированное)|
| unreadCount      | int     | Количество непрочитанных сообщений         |
| createdAt        | datetime| Дата и время создания чата                 |

### Сообщение (Message)

| Поле             | Тип     | Описание                                    |
|------------------|---------|---------------------------------------------|
| id               | int     | Уникальный идентификатор сообщения         |
| fromId           | int     | ID отправителя                             |
| toId             | int     | ID получателя                              |
| productId        | int     | ID товара, к которому относится сообщение  |
| content          | string  | Текст сообщения                            |
| timestamp        | string  | Отформатированное время отправки           |
| createdAt        | datetime| Точное время создания сообщения            |

## Обработка ошибок

Все API-эндпоинты в случае ошибки возвращают HTTP-код, соответствующий типу ошибки, и тело ответа в формате JSON:

```json
{
  "error": "Описание ошибки"
}
```

## Ограничения и лимиты

- Максимальный размер сообщения: 512 KB
- Таймаут бездействия для WebSocket-соединения: 65 секунд
- Период отправки ping-сообщений: 54 секунды

## Примеры использования

### Пример получения списка чатов

```
GET /api/chats?userId=123
```

### Пример получения истории сообщений

```
GET /api/messages?userId=123&chatWith=456
```

## Дополнительная информация о WebSocket протоколе

### Жизненный цикл WebSocket соединения

1. **Установка соединения**: Клиент подключается к `/ws/{userId}`
2. **Аутентификация**: Сервер проверяет валидность ID пользователя
3. **Регистрация**: Клиент регистрируется в системе и добавляется в список активных клиентов
4. **Обмен сообщениями**: Клиент отправляет и получает сообщения в реальном времени
5. **Пинг/Понг**: Сервер регулярно отправляет пинг-сообщения для поддержания соединения
6. **Завершение соединения**: При отключении клиента или таймауте бездействия соединение закрывается

### Протокол обмена сообщениями

#### Типы сообщений

1. **message** - Обычное текстовое сообщение между пользователями
   ```json
   {
     "type": "message",
     "fromId": 123,
     "toId": 456,
     "productId": 789,
     "content": "Текст сообщения"
   }
   ```

2. **status** - Обновление статуса пользователя
   ```json
   {
     "type": "status",
     "userId": 123,
     "status": "online",
     "isActive": true
   }
   ```

3. **typing** - Уведомление о наборе текста
   ```json
   {
     "type": "typing",
     "fromId": 123,
     "toId": 456,
     "productId": 789
   }
   ```

4. **read** - Отметка о прочтении сообщений
   ```json
   {
     "type": "read",
     "fromId": 123,
     "toId": 456,
     "productId": 789
   }
   ```

### Обработка сообщений 

1. Сообщение принимается через WebSocket
2. Происходит парсинг JSON
3. Проверяется тип сообщения
4. В зависимости от типа выполняется соответствующая обработка:
   - Для `message` - сохранение в БД и отправка получателю
   - Для `status` - обновление статуса пользователя и уведомление контактов
   - Для `typing` - передача уведомления получателю
   - Для `read` - обновление статуса прочтения в БД

### Процесс обработки сжатия и шифрования

Для обеспечения безопасности и оптимизации трафика, сообщения обрабатываются через процессорный конвейер:

1. **Сжатие** - Сообщения сжимаются алгоритмом snappy для уменьшения объема передаваемых данных
2. **Шифрование** - Сжатые данные шифруются для обеспечения безопасности
3. **Отправка** - Защищенные данные передаются через WebSocket

При получении сообщения происходит обратный процесс:
1. **Дешифрование** - Расшифровка зашифрованных данных 
2. **Распаковка** - Распаковка сжатых данных
3. **Обработка** - Обработка полученного сообщения

## Архитектура системы

### Компоненты системы

1. **WebSocket сервер** - Обрабатывает real-time соединения
2. **HTTP API** - Обрабатывает REST запросы
3. **Процессор сообщений** - Выполняет сжатие/шифрование 
4. **Слой доступа к БД** - Взаимодействует с базой данных MySQL

### Схема взаимодействия компонентов

```
Клиент <----> WebSocket <----> Процессор <----> БД
  ^            ^
  |            |
  +------------+
       HTTP
```

## Рекомендации по использованию API

1. Перед отправкой сообщений всегда проверяйте статус пользователя через эндпоинт `/api/status`
2. При отсутствии сообщений в течение длительного времени рекомендуется отправлять пинг-запросы
3. Размер сообщений не должен превышать 512 КБ
4. При ошибках соединения рекомендуется использовать экспоненциальный backoff для повторных попыток
5. Для мобильных клиентов рекомендуется использовать сжатие данных для экономии трафика 